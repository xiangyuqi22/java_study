package create.pattern.builderpattern.main;

import create.pattern.builderpattern.ChickenBurger;
import create.pattern.builderpattern.Meal;
import create.pattern.builderpattern.MealBuilder;

/**
 * 
 * <PRE>
 * 
 * 学习地址：http://www.runoob.com/design-pattern/builder-pattern.html
	
	建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。
	这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
	一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。
	
	意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
	
	主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；
	由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
	
	何时使用：一些基本部件不会变，而其组合经常变化的时候。
	
	如何解决：将变与不变分离开。
	
	关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系
	
	应用实例： 
		1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 
		2、JAVA 中的 StringBuilder。
	
	优点： 
		1、建造者独立，易扩展。
		2、便于控制细节风险。
	
	缺点： 
		1、产品必须有共同点，范围有限制。 
		2、如内部变化复杂，会有很多的建造类。
	
	使用场景：
	 	1、需要生成的对象具有复杂的内部结构。 
	 	2、需要生成的对象内部属性本身相互依赖。
	
	注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。
	
	自己的理解 ：
		某个产品由一系列的组件组合而成，不同的组件组合方法生成不同的产品。
 * </PRE>
 *
 * 项目名称：design_pattern</BR>
 * 技术支持：广东凯通科技股份有限公司 (c) 2017</BR>
 * 
 * @version 1.0 2019年4月23日
 * @author xiangning
 * @since JDK1.8
 */
public class BuilderPatternMain {
	
	public static void main(String[] args) {
		
		MealBuilder.builder(1).showItem();
		MealBuilder.builder(2).showItem();
		MealBuilder.builder(3).showItem();
		MealBuilder.builder(4).showItem();
		Meal meal = MealBuilder.builder(14);
		meal.showItem();
		meal.removeItem(ChickenBurger.class , false);
		meal.showItem();
		meal.removeItem(ChickenBurger.class , true);
		meal.showItem();
		ChickenBurger chickenBurger1 = new ChickenBurger();
		ChickenBurger chickenBurger2 = new ChickenBurger();
		meal.addItem(chickenBurger1 , chickenBurger2);
		meal.showItem();
		meal.removeItem(chickenBurger1.getClass(), true);
		meal.showItem();
	}

}
